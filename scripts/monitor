#!/usr/bin/env python

import rospy
from rosgraph_monitor.monitor_manager import MonitorManager, ServiceWrapper
from rosgraph_monitor.parser import ModelParser
from pyparsing import *
import os.path

from ros_graph_parser.srv import GetROSModel, GetROSSystemModel
from diagnostic_msgs.msg import DiagnosticArray, DiagnosticStatus


def strip_slash(string):
    return '{}'.format(string[1:] if string.startswith('/') else string)


class GraphScanService(ServiceWrapper):
    def __init__(self, haros_model):
        super(GraphScanService, self).__init__(
            'get_rossystem_model', GetROSSystemModel)
        self._rossystem_parser = ModelParser(haros_model)

    # This function needs to be implemented by every service wrapper
    # extract diagnostics from response here
    def diagnostics_from_response(self, resp):
        parser = ModelParser(resp.model, isFile=False)
        dynamic_model = parser.parse()
        static_model = self._rossystem_parser.parse()

        missing_interfaces, additional_interfaces = self.compare_models(
            static_model, dynamic_model)

        status_msgs = list()
        if (not missing_interfaces) & (not additional_interfaces):
            status_msg = DiagnosticStatus()
            status_msg.level = DiagnosticStatus.OK
            status_msg.name = "ROS Graph"
            status_msg.message = "running OK"
            status_msgs.append(status_msg)

        else:
            # Here are 2 'for loops' - 1 for missing and 1 for additional
            for interface in missing_interfaces:
                status_msg = DiagnosticStatus()
                status_msg.level = DiagnosticStatus.ERROR
                status_msg.name = interface
                status_msg.message = "Missing node"
                status_msgs.append(status_msg)

            for interface in additional_interfaces:
                status_msg = DiagnosticStatus()
                status_msg.level = DiagnosticStatus.ERROR
                status_msg.name = interface
                status_msg.message = "Additional node"
                status_msgs.append(status_msg)

        return status_msgs

    # find out missing and additional interfaces
    # if both lists are empty, system is running fine
    def compare_models(self, model_ref, model_current):
        # not sure of the performance of this method
        set_ref = set((strip_slash(x.interface_name[0]))
                      for x in model_ref.interfaces)
        set_current = set((strip_slash(x.interface_name[0]))
                          for x in model_current.interfaces)

        # similarly for all interfaces within the node?
        # or only for topic connections?
        # does LED's code capture topic connections?

        # returning missing_interfaces, additional_interfaces
        return list(set_ref - set_current), list(set_current - set_ref)


if __name__ == "__main__":
    rospy.init_node('graph_monitor')
    manager = MonitorManager()

    my_path = os.path.abspath(os.path.dirname(__file__))
    path = os.path.join(
        my_path, "../resources/cob4-25.rossystem")

    # how can this be read from a YAML file
    # ideally should have service name and type only
    graph_service = GraphScanService(path)
    manager.register_service(graph_service)

    manager.loop()
    rospy.spin()
